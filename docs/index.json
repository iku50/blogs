[{"categories":"distribute system","content":"MIT 6-5840","date":"2023-03-22","objectID":"/blogs/post/65840lab1/","tags":["distribute","go"],"title":"MIT6-5840Lab1记录","uri":"/blogs/post/65840lab1/"},{"categories":"distribute system","content":"MIT6-5840Lab1 这次的 Lab 来源于 MIT 6-5840，过去的一周中都在被这个 Lab 折磨。好歹还是完成了。在这里记录一下。 ","date":"2023-03-22","objectID":"/blogs/post/65840lab1/:1:0","tags":["distribute","go"],"title":"MIT6-5840Lab1记录","uri":"/blogs/post/65840lab1/"},{"categories":"distribute system","content":"0.事先准备 首先当然是简单地克隆一下今年课程代码。 git clone git://g.csail.mit.edu/6.5840-golabs-2023 6.5840 接着按照 guide 中的指示稍微过一遍程序流程。 稍微看一遍 guide，着重看一下 your job 的部分，rules 和 hints 等到开始写代码时再看。 它的要求是用三个文件 mr/coordinator.go, mr/worker.go 和 mr/rpc.go实现一个简单的MapRduce系统 coordinator.go 文件负责在MapReduce论文中的Master部分，只不过改了个Coordinator的名字，主要工作就是派发任务给workers，要有判断目前算法阶段以派发不同任务的功能，在后面的实现中，发现还需要能够判断某worker是否出问题来把任务派发给其他worker。 rpc.go 文件负责在Workers和Coordinator之间进行通讯，通讯的流程我们不关注，只需要知道使用的方法。 Worker.go 文件负责具体的工作部分，需要能够处理Map任务和Reduce任务。 阅读了MapReduce算法的论文后，开始编写代码。 代码编辑用的是Goland，很好用。 ","date":"2023-03-22","objectID":"/blogs/post/65840lab1/:1:1","tags":["distribute","go"],"title":"MIT6-5840Lab1记录","uri":"/blogs/post/65840lab1/"},{"categories":"distribute system","content":"1.MapReduce 逻辑 首先编写Worker逻辑，由底层实现开始 Worker.go 逻辑的实现首先可以放眼 Map 函数和 Reduce 函数的实现，基本上是从它自带的 mrsequential.go中抄代码的过程，稍微修改后发现其所需要的一些必须数据，因此将这些数据统一为 Task 类在 rpc.go文件中。 type Task struct { ID int Worker int Type string //Map,Reduce,Done,Waiting ReduceNum int MapNum int MapFile string Deadline time.Time } 这里的 Type 用来描述 Task 的状态。 注意这里的内部变量必须全部首字母大写，不然其他文件调用不了（golang 用首字母大小写确定公私有关系） ","date":"2023-03-22","objectID":"/blogs/post/65840lab1/:1:2","tags":["distribute","go"],"title":"MIT6-5840Lab1记录","uri":"/blogs/post/65840lab1/"},{"categories":"distribute system","content":"2. 程序流程 这时必须审视一下程序流程了，首先对于一个worker来说，最好的状态是收到task后工作完成紧接着继续收到一个task。毕竟程序不用休息。那么最好的方法其实是在每一个task完成后向coordinator报告并获取下一个task。 这样想的话，考虑到在Map和Reduce中间肯定会有Worker因为所有Map任务都派发完陷入等待其他Worker完成剩余的Map任务后一起进入Reduce任务的状态下，由hints中的提示，将Task分为四种Type： Map,Reduce 在这种状态下，Worker应该马上开始工作。 Waiting 在这种状态下，Worker应该等待一段时间后再发送请求任务 Done 在这种状态下，Worker应该结束自身。 于是我们理清了Worker的流程。 而考虑到RPC，在上述的状态描述下，它只需要处理Worker发出的申请任务请求和Coordinator的Task回应就可以了。 这里等于说，我们将Worker的申请任务请求和完成任务报告（应该含有worker的ID和Task）合二为一。 对于Coordinator，它首先需要一个锁来处理不同线程试图对它进行访问时的可能发生的竞争，然后需要一个变量保存目前总任务的状态信息，另外需要Map任务的总数量和Reduce任务的总数量，以给任务分配ID，再加一个空闲任务的列表（最好是一个先进先出的列表，而golang中的channel就是一个很好的实现工具） 在后面的测试流程中，发现在worker的waiting状态下，coordinator需要对目前完成的任务进行判断以来确定是否所有任务都已经被完成，才能进入下一个阶段或者是结束流程。所以需要变量保存已完成的任务数和任务总数。 在这里我们看到申请任务请求要返回的上一个任务的Task，如果要直接返回将是很大的一笔消耗。所以在这里我们想到可以在Coordinator里面保存Task的具体信息，而只需要Worker发来的TaskID数据就能够验证处理了。 但这样的话又遇到另一个问题，等一下对这个问题进行具体描述，我们先继续完成这一部分的逻辑。 这样的话，具体编写后发现coodirnator需要四个方法 MakeCoordirnator() 用来初始化Coordirnator的构造函数 ApplyForTask() RPC调用所需要的函数，用来生成派发任务 MapFile()和ReduceFile() 用来生成中间文件和最终文件 MakeCoordirnator方法暂时只是构造函数不谈。我们先看看ApplyForTask方法。 ApplyForTask需要首先处理Worker传回来的上一个Task，将其处理成中间文件或者最终文件，并判断是否可以进入下一个阶段，即所有该阶段任务是否已经被完成，这里我们可以使用保存的Task的清单，既然清单上的任务完成了那么划掉就可以了吧，因此我们在任务列表中删除该完成的任务并且当任务列表清零时就可以判断出所有该阶段任务已经被完成。当然，如果Worker是刚开始申请任务还没有完成任何一个任务就跳过这部分。 接着，ApplyForTask从空闲的任务中派发任务出去，如果为刚刚进入Reduce阶段的话应该在刚刚就生成了一批新的Task任务可供派发。如果是Waiting或者Done的话应该在之前的逻辑中就返回了。所以这里绝对有空闲任务可供派发。 欧克，我们照着这个流程走一次，就会发现其他test通过，但crash_test失败了。 ","date":"2023-03-22","objectID":"/blogs/post/65840lab1/:1:3","tags":["distribute","go"],"title":"MIT6-5840Lab1记录","uri":"/blogs/post/65840lab1/"},{"categories":"distribute system","content":"3. 崩溃处理 这里的崩溃在我们阅读了日志信息后发现，是因为worker提前退出了，而coordinator还在等待worker的任务完成后才能清零任务进入下一阶段。 好吧，既然worker退出了，那首先就需要有东西检测到它退出才可以。 我们可以在worker和coordinator之间建立一个heratbeat，每隔一段时间worker就要跟coordinator发信息表明自己存活。没发就当worker死了。但这里我们使用另一种方法，就是为每一个Task设置一个limittime，在coordinator那设置一个专门的goroutine来检测所有未完成task有没有超时，超时就将task加入空闲task的channel里给其他线程用。 但这里有一个问题，就是当worker虽然超时了但没有退出，实际上可能只是它处理的慢了一点，或者中间暂停了一会儿，那么重新发放任务时的对两个线程处理一个任务的竞争怎么解决？ 那么就用新建的但沿袭之前任务各项数据的任务派发给后来者吧。 那么当先前的worker也发放了自己的结果给coordinator，那么对于两段同样的任务该如何处理？ 所以我们需要worker和Task之间的对应，在每一个task都应该有处理它的worker的ID，当任务被二次派发时WorkerID也随之覆盖。这时超时worker的返回Task就是不合法的，直接照表一查就知道，这时只需要丢弃这个信息就可以了。 这就是崩溃中的检测和二次派发。在处理完这部分的代码后终于看到所有测试都通过了（事实上这是最耗时间精力的部分） ","date":"2023-03-22","objectID":"/blogs/post/65840lab1/:1:4","tags":["distribute","go"],"title":"MIT6-5840Lab1记录","uri":"/blogs/post/65840lab1/"},{"categories":"distribute system","content":"感想 啊，好难啊，后面据说更难。遗憾就是没有优雅地处理好worker的退出。有思路和想法但暂时不想动这个Lab了，先就这样吧。 ","date":"2023-03-22","objectID":"/blogs/post/65840lab1/:1:5","tags":["distribute","go"],"title":"MIT6-5840Lab1记录","uri":"/blogs/post/65840lab1/"},{"categories":"database","content":"CMU 15-445","date":"2023-03-12","objectID":"/blogs/post/cmu15445pro0/","tags":["database","c++"],"title":"CMU15445-pro0记录","uri":"/blogs/post/cmu15445pro0/"},{"categories":"database","content":"CMU15445-pro0记录 之前的网站现在开始更新了，主要放一些 lab 的记录之类的，这里是CMU的经典数据库课程 CMU15-445 的 lab 记录分析。 Lab是CMU15-445 Spring（2023） 课听的是FALL（2022）的，毕竟是Andy的。 ","date":"2023-03-12","objectID":"/blogs/post/cmu15445pro0/:1:0","tags":["database","c++"],"title":"CMU15445-pro0记录","uri":"/blogs/post/cmu15445pro0/"},{"categories":"database","content":"Project 0 - C++Primer Project 0 主要是对编程能力的一个小考核。如果没能完成它那实际上是没有达到上这门课的水平的。在这一季的课程里的 Project 0 跟之前有所不同。主体上是利用Modern C++实现一个 Copy-On-Write 字典树。 0：Lab 前准备 由于我用的是 Manjaro 的 Linux 系统，所以不能直接满足它的环境要求（Mac 或 ubuntu），所以这里我用 Docker 安装一个 ubuntu20.04 的容器。并用 vscode 自带的远程开发连接到容器内，再 push 下来一键部署。值得注意的是，这个工程需要用到 Clang 编译，而不是我们常见的 gcc。 1：Task #1 Copy-On-Write Trie 仔细阅读了它网站上的文档内容和相关的代码文件后，发现它在这一阶段考察 Modern C++ 的知识点有以下两个： 模板 智能指针（std::shared_ptr 和 std::unique_ptr） 其中智能指针是考察的重点。 而就算法而言，三个要求实现的方法：Get，Put，Remove，要求用 Copy-On-Write 的方式实现，在文档的示例中有所演示。其核心思想是，在改写字典树的过程中，任何需要发生变动的节点的实际变动都由其克隆体完成，本身不变。换句话说，通过改写字典树，我们实际上可以得到两棵不一样且功能正常的字典树。原字典树不变，新字典树能用原字典树的节点就用，不能用就新建节点。 Get 方法的实现过程比较简单，除了几个需要特殊处理的情况外，大体的思想是按提供的 std::string_view 进行由顶至下的字符匹配需要注意的是返回的结果需要用 dynamic_cast 进行转型，因为是由基类 TrieNode 转继承类 TrieNodeWithValue 。且由于模板的存在，Value 的类型可能会不一样，所以需要动态的类型检查，因此这里必须用 dynamic_cast 进行判断。 Put 方法的实现稍显复杂，因为 Copy-on-Write 的特性要求，所以比一般的字典树实现多了要把改变节点的根节点也进行复制替换。所以这里建了一个 std::vector 来保存字典树进行搜索时的路径，而一旦搜索结束且叶子节点都完成替换或创建（当 key 对应的叶子节点不存在时就新建立节点），就向上回溯进行替换。 Remove 方法大体上延续 Put 方法的思路，主要是要当节点无值且无子节点时就要删除节点。因此向上回溯的过程里多一个判断是否无值且无子节点就可以了。 最后的测试结果如下： Task #2 Concurrent Key-Value Store 完成 Copy-on-write trie 后，要完成并发键值存储。以适应多线程下的操作。一样是那三个方法。实现需要的就是理解多线程下互斥锁的功能。在 C++ 里，互斥锁是 std::Mutex ，在头文件里已经帮我们实现了读写锁，要求我们实现写读可同时进行，那么其实要做的就非常容易了。 对于 Get，直接使用上面我们实现的方法，只需在前面加上在加锁解锁间复制根节点指针，并让之后的 Get 操作都对这个复制的指针进行就可以了。 对 Put 方法，因为已经实现了 Copy-on-Write 。所以比一般的字典树相比，写是在新的字典树上写，读可以在旧有的字典树上读，这是读写可以同时进行的关键，在这里它要求我们用它给的写锁实现读写同时进行这一功能。所以大体上，首先保证只有一个写者，所以方法使用时写锁必须全程保持 Lock，而读锁只需要在取出根和放回修改后的新根的时候是 Lock 的就行。保持这个思路去写就没问题。 Remove 方法与 Put 方法的思路一样。 下面是测试内容。 Task #3 - Debugging 这里没什么好说的，设置断点在 vscode 中直接看就行。 Task #4 - SQL String Functions 这一个 Task 放在这里主要是让我们熟悉流程用的，要求实现 Upper 方法和 Lower 方法。这个是个人都会写。在C++里分别只需要使用 std 里自带的 transform 函数就可以了。主要是要把方法注册到 SQL 中使其能够使用，一个简单的 if-else 结构就能完成。 简单测试一下没什么问题。 接着运行它给我们的三个数据库上的测试 基础测试： 异常测试： 字符串扫描测试： 这里发现异常测试的输出信息有点问题，后面进行了调整。 ","date":"2023-03-12","objectID":"/blogs/post/cmu15445pro0/:1:1","tags":["database","c++"],"title":"CMU15445-pro0记录","uri":"/blogs/post/cmu15445pro0/"},{"categories":"database","content":"总结 作为一个入门级别的 Project ，这个项目是确实挺全面的。Modern C++的各项内容都有考察到。对我这个普通大二学生来说算是适中的难度。工程量很小，加起来估计一两百行的代码。写的时间加起来大概是 4 到 5 个小时。总体来说，对于之后的学习，算是个良好的开端吧。 ","date":"2023-03-12","objectID":"/blogs/post/cmu15445pro0/:1:2","tags":["database","c++"],"title":"CMU15445-pro0记录","uri":"/blogs/post/cmu15445pro0/"},{"categories":"git","content":"给纯新手阅读的github使用教程","date":"2022-04-29","objectID":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","tags":["github"],"title":"Github新手使用教程","uri":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":"git","content":"应要求写的一份 ","date":"2022-04-29","objectID":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","tags":["github"],"title":"Github新手使用教程","uri":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":"git","content":"为纯新手考虑的github使用教程！ 首先，github的国内访问一直不稳定，虽然可以用改host的方式浅解决一下，但因为这是为纯新手准备的所以建议直接用魔法进行超空间信息连接。因为是黑魔法所以方法不列。 ","date":"2022-04-29","objectID":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","tags":["github"],"title":"Github新手使用教程","uri":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":"git","content":"注册 请在github.com 上注册一个帐号。 ","date":"2022-04-29","objectID":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:1","tags":["github"],"title":"Github新手使用教程","uri":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":"git","content":"git 然后，进入git官网 https://git-scm.com/ 点右侧的Download for [你的操作系统]，下载完成后安装步骤如： 点右侧的Download for Windows，下载完成后安装步骤如： windows： https://www.jianshu.com/p/414ccd423efc Mac用户请转如下博客进行安装与基本使用教程 https://www.csdn.net/tags/MtjaIgxsMzUzNjUtYmxvZwO0O0OO0O0O.html [ Linux: ] 用linux的人不会连git都不知道怎么安吧 ","date":"2022-04-29","objectID":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:2","tags":["github"],"title":"Github新手使用教程","uri":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":"git","content":"在github上对项目进行贡献 因为写这篇文章真正的目的和我懒得写的缘故，所以如何创建自己的仓库我就略了。 当然，这个项目必须你为项目所有者或者所有者把你设置为合作者才可以直接对其修改的。 如果不是合作者的话，点击右上方的fork按钮按这个分支创建完全属于自己的新仓库，修改后向原作者提交合并请求，原作者同意后即可。 下面默认你为合作者。 登录github，在左上角的搜索栏中搜索关键词，比如https://github.com/iku50/iku50.github.io 点击进入该库后，找到绿色的code按钮，默认是https的clone方式，这就对了。点右侧的复制按钮将此地址一键复制。 在本地的某个空文件夹内，windows是用右键选中用git bash打开，输入命令 git clone [刚刚复制的url地址] 等待！ 然后等它下载完毕就可以看到整个项目都已经在你的文件夹内了。 然后我们试图往文件夹内加点东西。 比如把一张图片放进去？ 就像你平常那样操作就好了。 然后用git bash输入命令。 git add . //这个点指的是加入所有文件到暂存区,或者你也可以把.改为具体的文件名。 git commit -m \"更改信息,这里填啥都可以，主要是填你做的哪些改变\"//指提交信息到本地仓库 git push origin main:main//前面的origin是远程主机名（一般都默认叫这个），前一个main是本地分支名，后一个是远程分支名，像这种远程分支和本地分支一个名字的可以省略掉后面的:main，即 git push origin main 当然有时git会提醒你远程和本地分支不同步所以无法上传，这是因为有其他人更新了远程分支，这时，需要用 git pull origin main:main//即从远程的origin主机的main分支合并到本地的main分支里面。这里后面的main是本地分支名，如果远程分支是与当前分支合并那么可以省略。 然后再试一遍push看看！应该可以上传了。 更多的分支操作可以查看以下教程https://www.runoob.com/git/git-tutorial.html 然后登录github找到该项目，可以看到你已经成功了！ ","date":"2022-04-29","objectID":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:3","tags":["github"],"title":"Github新手使用教程","uri":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":"git","content":"不需要敲代码的方式！ 在提醒之下，我突然回忆起不敲代码也能上传文件和下载文件！ 这样连安装git都不用！只要注册就好了！ 下载项目（如果只要上传文件的话这步也能略！） 还是那个绿色的code按钮，点击选择Download Zip！ 于是就直接下载好了压缩包。 上传文件 先在项目仓库上切换到需要上传到的文件夹。 点code旁边的add file按钮，选择upload files。 直接把要上传的文件拖到Drag…那个区域 默认吧默认就行。 点绿色的commit changes就好了。 ","date":"2022-04-29","objectID":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:4","tags":["github"],"title":"Github新手使用教程","uri":"/blogs/post/github%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"AboutMe! HUST计院学生。 后端学习的入门者。 所以这个网站用来放一些学习笔记。 ","date":"2022-04-27","objectID":"/blogs/about/:0:1","tags":null,"title":"About","uri":"/blogs/about/"},{"categories":"web","content":"本文用来展示用hugo等工具建站的流程","date":"2022-04-25","objectID":"/blogs/post/buildwebsite/","tags":["hugo","website"],"title":"建站！","uri":"/blogs/post/buildwebsite/"},{"categories":"web","content":"用hugo+github pages托管+阿里云ecs建站 现在发现hugo和github pages就行了，阿里云要花钱不如不用。 之前是用wordpress建站的，但实在受不了它每次超慢的线上操作，而且对md格式文件的支持也不够好。因此在查询资料后决定通过hugo建立静态博客。 ","date":"2022-04-25","objectID":"/blogs/post/buildwebsite/:1:0","tags":["hugo","website"],"title":"建站！","uri":"/blogs/post/buildwebsite/"},{"categories":"web","content":"前期准备 0. 资源准备 阿里云ECS服务器（或者别的什么腾讯云等服务器也行，因为github pages托管在国内访问速度太慢，所以用DNS解析到国内的服务器绑定的域名上）。 go环境安装。 一个自己拥有的独立域名（10块钱买一个不成问题）。 1. hugo安装 由于我是manjaro系统，且之前早就已经安装好了go环境，所以我只需要用snap直接安装hugo即可。 sudo snap install hugo 然后检查一下版本看是否安装成功。 \u003e\u003e\u003e hugo version hugo v0.96.0-2fd4a7d3d6845e75f8b8ae3a2a7bd91438967bbb linux/amd64 BuildDate=2022-03-26T09:15:58Z VendorInfo=mage 2. github pages库创建 在自己的github上建一个新的仓库，名为 用户名.github.io。 注意该仓库必须是public的。 在本地创建一个新文件夹，用git把仓库克隆下来。 git clone \u003c仓库的url\u003e ","date":"2022-04-25","objectID":"/blogs/post/buildwebsite/:1:1","tags":["hugo","website"],"title":"建站！","uri":"/blogs/post/buildwebsite/"},{"categories":"web","content":"建站 1. 本地网站部署 在此目录下打开终端，敲入一下命令创建网站。 hugo new site . #如果显示说此目录下已经有文件就在后面加个' --force'强制操作 在跳出来的信息中。 Congratulations! Your new Hugo site is created in /home/rickeee/website/test. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \"hugo new theme \u003cTHEMENAME\u003e\" command. 2. Perhaps you want to add some content. You can add single files with \"hugo new \u003cSECTIONNAME\u003e/\u003cFILENAME\u003e.\u003cFORMAT\u003e\". 3. Start the built-in live server via \"hugo server\". Visit https://gohugo.io/ for quickstart guide and full documentation. 可以看到 Choose a theme from https://themes.gohugo.io/这一项，直接点链接或者复制到浏览器打开挑选喜欢的主题。 挑选好后查看其github页面获取url，再在网站目录里用git下载。 git init git submodule add \u003c主题的url地址\u003e 采用 submodule管理theme会比较好更新管理。 进入theme文件夹找到该主题。进入该主题文件夹找到 exampleSite/config.toml文件，复制下来并覆盖掉根目录下的同名文件。 打开该文件，修改一下要修改的属性（网站名，副标题，该主题希望你进行选择的一些参数等）（一般旁边有注释帮助理解）（还有一些必须修改的稍后讲） 可以在根目录打开终端用以下命令构建网站： hugo 开启网站服务 hugo server 在浏览器中打开 http://localhost:1313看看效果 4. github pages托管 记得之前的 config.toml文件吗，其中有一项是需要修改的。 baseURL = \"https://\u003cgithub仓库的url\u003e\" 在根目录用git push到远程仓库上 在github上设置page参数 把source选项中的 /(root)改成 /docs。方便后面生成。 在本地的网站根目录下打开终端改生成网页的目录到docs文件夹下（默认会生成在public文件下所以需要改） hugo -d docs 然后就可以打开 https://\u003c库url\u003e看到自己的网页了 5. DNS解析设置 在如果是阿里云上购买的域名，那么在阿里云的控制台上进入域名设置界面，为服务器绑定域名（主机记录为@，值为服务器的公网ip地址），并添加一个CNAME类型的记录，主机记录可以是 blog，值就是github pages部署的自己网站的地址。 设置完后在网站根目录的static文件夹下创建一个CNAME文件，打开并写入设置的域名（若前面主机记录是blog即 blog.\u003c你的域名\u003e）。 重新生成一下并 push到github上。 改变github pages设置中的custom domian为设置的新域名。 然后就可以用自己的域名访问了。 ","date":"2022-04-25","objectID":"/blogs/post/buildwebsite/:1:2","tags":["hugo","website"],"title":"建站！","uri":"/blogs/post/buildwebsite/"},{"categories":"web","content":"其他注意事项 写博客时用： hugo new posts/\u003c文章名.md\u003e 创建新文章。 写完后记得把文章头部的 draft属性设置为 false，不然就是默认为草稿不生成文章。 ","date":"2022-04-25","objectID":"/blogs/post/buildwebsite/:1:3","tags":["hugo","website"],"title":"建站！","uri":"/blogs/post/buildwebsite/"}]